use crate::audio_converter::AudioConverter;
use crate::audio_sink::{AudioError, AudioSink, CpalConfig, CpalSink};
use futures::StreamExt;
use log::{debug, error, info, warn};
use std::sync::Arc;
use tokio::sync::mpsc;
use tonic::transport::Server;
use tonic::{Request, Response, Status, Streaming};

use audio::audio_service_server::{AudioService, AudioServiceServer};
use audio::{
    play_audio_request, AbortRequest, AbortResponse, AudioChunk, AudioFormat, EndStreamRequest,
    EndStreamResponse, PlayAudioRequest, PlayResponse, SubscribeRequest,
};

// Generated by tonic-build
pub mod audio {
    tonic::include_proto!("audio");
}

/// Helper function to extract f32 samples from AudioChunk
fn extract_f32_samples(chunk: &AudioChunk) -> Result<Vec<f32>, Status> {
    match &chunk.samples {
        Some(audio::audio_chunk::Samples::FloatSamples(bytes)) => {
            // Convert f32 bytes to f32 samples
            if bytes.len() % 4 != 0 {
                return Err(Status::invalid_argument("Invalid f32 sample data length"));
            }
            let mut samples = Vec::with_capacity(bytes.len() / 4);
            for chunk in bytes.chunks(4) {
                let f32_sample = f32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]);
                samples.push(f32_sample);
            }
            Ok(samples)
        }
        Some(audio::audio_chunk::Samples::Int16Samples(bytes)) => {
            // Convert i16 bytes to f32 samples
            if bytes.len() % 2 != 0 {
                return Err(Status::invalid_argument("Invalid i16 sample data length"));
            }
            let mut samples = Vec::with_capacity(bytes.len() / 2);
            for chunk in bytes.chunks(2) {
                let i16_sample = i16::from_le_bytes([chunk[0], chunk[1]]);
                let f32_sample = i16_sample as f32 / 32768.0;
                samples.push(f32_sample);
            }
            Ok(samples)
        }
        Some(audio::audio_chunk::Samples::Int32Samples(bytes)) => {
            // Convert i32 bytes to f32 samples
            if bytes.len() % 4 != 0 {
                return Err(Status::invalid_argument("Invalid i32 sample data length"));
            }
            let mut samples = Vec::with_capacity(bytes.len() / 4);
            for chunk in bytes.chunks(4) {
                let i32_sample = i32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]);
                let f32_sample = i32_sample as f32 / 2147483648.0;
                samples.push(f32_sample);
            }
            Ok(samples)
        }
        Some(audio::audio_chunk::Samples::Float64Samples(bytes)) => {
            // Convert f64 bytes to f32 samples
            if bytes.len() % 8 != 0 {
                return Err(Status::invalid_argument("Invalid f64 sample data length"));
            }
            let mut samples = Vec::with_capacity(bytes.len() / 8);
            for chunk in bytes.chunks(8) {
                let f64_sample = f64::from_le_bytes([
                    chunk[0], chunk[1], chunk[2], chunk[3], chunk[4], chunk[5], chunk[6], chunk[7],
                ]);
                samples.push(f64_sample as f32);
            }
            Ok(samples)
        }
        Some(audio::audio_chunk::Samples::Int24Samples(_)) => {
            // TODO: Implement i24 conversion
            Err(Status::unimplemented("i24 sample format not yet supported"))
        }
        None => Err(Status::invalid_argument("No samples data in AudioChunk")),
    }
}

/// Active audio stream information
struct ActiveStream {
    stream_id: String,
    abort_tx: mpsc::Sender<()>,
    task_handle: tokio::task::JoinHandle<Result<(), AudioError>>,
}

/// Main audio service implementation
pub struct AudioServiceImpl {
    audio_sink: Arc<dyn AudioSink>,
    target_format: AudioFormat,
}

impl AudioServiceImpl {
    pub fn new(audio_sink: Arc<dyn AudioSink>) -> Result<Self, AudioError> {
        let target_format = audio_sink.get_format();
        info!(
            "üîä Audio sink created with target format: {}Hz, {}ch, {}",
            target_format.sample_rate, target_format.channels, target_format.sample_format
        );

        Ok(Self {
            audio_sink,
            target_format,
        })
    }

    pub fn new_with_config(config: CpalConfig) -> Result<Self, AudioError> {
        let audio_sink = Arc::new(CpalSink::new(config)?);
        let target_format = audio_sink.get_format();
        info!(
            "üîä Audio sink created with target format: {}Hz, {}ch, {}",
            target_format.sample_rate, target_format.channels, target_format.sample_format
        );

        Ok(Self {
            audio_sink,
            target_format,
        })
    }

    /// Handle audio playback for a specific stream
    async fn handle_playback(
        &self,
        mut stream: tonic::Streaming<PlayAudioRequest>,
    ) -> Result<PlayResponse, Status> {
        let mut current_stream_id = None;
        let mut converter: Option<AudioConverter> = None;
        let mut chunks_played = 0;

        info!("üîä Starting playback stream processing");

        while let Some(request) = stream.next().await {
            debug!("üîä Received request from stream");
            let request = request?;

            match request.data {
                Some(play_audio_request::Data::Chunk(chunk)) => {
                    // Initialize stream if this is the first chunk
                    if current_stream_id.is_none() {
                        current_stream_id = Some(request.stream_id.clone());
                        info!("üîä Initializing playback stream: {}", request.stream_id);

                        // Extract format from first chunk
                        let input_format = chunk.format.as_ref().ok_or_else(|| {
                            Status::invalid_argument("First chunk must include format metadata")
                        })?;

                        // Create converter using pre-configured target format
                        let conv = AudioConverter::new(input_format, &self.target_format).map_err(
                            |e| Status::invalid_argument(format!("Audio format error: {e}")),
                        )?;
                        converter = Some(conv);
                        info!("üîä Playback stream initialized successfully");
                    }

                    // Extract f32 samples from the chunk
                    let f32_samples = extract_f32_samples(&chunk)?;

                    debug!(
                        "üîä Processing chunk {} with {} samples",
                        chunks_played + 1,
                        f32_samples.len()
                    );

                    // Validate chunk size (allow variable, just buffer)
                    if f32_samples.is_empty() {
                        return Err(Status::invalid_argument("Empty audio chunk"));
                    }

                    // Check for backpressure before processing
                    if self.audio_sink.is_backpressure_active() {
                        warn!(
                            "üîä Backpressure detected - buffer at {}%, slowing down processing",
                            self.audio_sink.get_buffer_percentage()
                        );
                        // Add a small delay to help with backpressure
                        tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;
                    }

                    // Feed samples to converter and write all available output
                    if let Some(ref mut conv) = converter.as_mut() {
                        let processed = conv.convert(&f32_samples).map_err(|e| {
                            Status::internal(format!("Audio conversion error: {e}"))
                        })?;

                        debug!(
                            "üîä Converter processed {} samples into {} bytes",
                            f32_samples.len(),
                            processed.len()
                        );

                        if !processed.is_empty() {
                            // The converter now returns data in the correct format for the sink
                            // Handle backpressure transparently - retry a few times before giving up
                            let mut retries = 0;
                            const MAX_RETRIES: u32 = 3;

                            loop {
                                match self.audio_sink.write(&processed).await {
                                    Ok(_) => break,
                                    Err(AudioError::BufferFull) if retries < MAX_RETRIES => {
                                        retries += 1;
                                        log::debug!(
                                            "üîä Buffer full, retry {}/{} - applying natural backpressure",
                                            retries, MAX_RETRIES
                                        );
                                        // Use a small delay to let the audio buffer drain
                                        tokio::time::sleep(tokio::time::Duration::from_millis(10))
                                            .await;
                                        continue;
                                    }
                                    Err(e) => {
                                        error!("Failed to write audio data: {}", e);
                                        return Err(Status::internal(format!(
                                            "Playback error: {}",
                                            e
                                        )));
                                    }
                                }
                            }

                            chunks_played += 1;
                            debug!(
                                "üîä Played chunk {} for stream {}",
                                chunks_played,
                                current_stream_id.as_ref().unwrap()
                            );
                        } else {
                            info!("üîä Converter returned empty output, buffering samples");
                        }
                    }
                }
                Some(play_audio_request::Data::EndStream(_)) => {
                    // Flush any remaining samples
                    if let Some(ref mut conv) = converter.as_mut() {
                        let processed = conv.flush().map_err(|e| {
                            Status::internal(format!("Audio conversion error: {e}"))
                        })?;

                        debug!("üîä Flush processed {} bytes", processed.len());

                        if !processed.is_empty() {
                            // The converter now returns data in the correct format for the sink
                            self.audio_sink.write(&processed).await.map_err(|e| {
                                error!("Playback error: {}", e);
                                Status::internal(format!("Playback error: {}", e))
                            })?;
                            chunks_played += 1;
                        }
                    }
                    info!(
                        "üîä Stream {} ended normally",
                        current_stream_id.as_ref().unwrap_or(&"unknown".to_string())
                    );
                    break;
                }
                None => {
                    return Err(Status::invalid_argument("Missing data in PlayAudioRequest"));
                }
            }
        }

        // Signal that no more audio will be sent
        info!("üîä Signaling end of stream...");
        self.audio_sink.signal_end_of_stream().await.map_err(|e| {
            error!("Failed to signal end of stream: {}", e);
            Status::internal(format!("Failed to signal end of stream: {}", e))
        })?;

        // Wait for all audio to finish playing before returning
        info!("üîä Waiting for audio playback to complete...");
        self.audio_sink.wait_for_completion().await.map_err(|e| {
            error!("Failed to wait for audio completion: {}", e);
            Status::internal(format!("Failed to wait for audio completion: {}", e))
        })?;

        info!("üîä Playback completed: {} chunks played", chunks_played);
        Ok(PlayResponse {
            success: true,
            message: format!(
                "Playback completed successfully. {} chunks played.",
                chunks_played
            ),
        })
    }
}

#[tonic::async_trait]
impl AudioService for AudioServiceImpl {
    type SubscribeAudioStream =
        std::pin::Pin<Box<dyn futures::Stream<Item = Result<AudioChunk, Status>> + Send + 'static>>;

    async fn subscribe_audio(
        &self,
        _request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeAudioStream>, Status> {
        // Audio capture functionality removed - focusing on playback only
        Err(Status::unimplemented(
            "Audio capture not implemented in this version",
        ))
    }

    async fn play_audio(
        &self,
        request: Request<tonic::Streaming<PlayAudioRequest>>,
    ) -> Result<Response<PlayResponse>, Status> {
        info!("üîä Starting audio playback stream");
        let stream = request.into_inner();
        let result = self.handle_playback(stream).await;
        match &result {
            Ok(response) => info!("üîä Audio playback completed: {}", response.message),
            Err(e) => error!("üîä Audio playback failed: {}", e),
        }
        Ok(Response::new(result?))
    }

    async fn end_audio_stream(
        &self,
        request: Request<EndStreamRequest>,
    ) -> Result<Response<EndStreamResponse>, Status> {
        let stream_id = request.into_inner().stream_id;
        info!("‚èπÔ∏è Ending audio stream: {}", stream_id);

        // Stream management removed - streams are handled per-request now
        Ok(Response::new(EndStreamResponse {
            success: true,
            message: "Stream ended successfully".into(),
            chunks_played: 0, // TODO: Track chunks played
        }))
    }

    async fn abort_playback(
        &self,
        request: Request<AbortRequest>,
    ) -> Result<Response<AbortResponse>, Status> {
        let stream_id = request.into_inner().stream_id;
        info!("üõë Aborting audio playback: {}", stream_id);

        // Stream management removed - streams are handled per-request now
        Ok(Response::new(AbortResponse {
            success: true,
            message: format!("Stream {} aborted successfully", stream_id),
        }))
    }
}

/// Helper function to create and run the Tonic server on TCP
pub async fn run_server(
    addr: std::net::SocketAddr,
    service: AudioServiceImpl,
) -> Result<(), Box<dyn std::error::Error>> {
    let svc = AudioServiceServer::new(service);

    info!("üéµ Audio service listening on TCP {}", addr);

    Server::builder().add_service(svc).serve(addr).await?;

    Ok(())
}

/// Helper function to create and run the Tonic server on Unix domain socket
pub async fn run_server_unix(
    socket_path: &str,
    service: AudioServiceImpl,
) -> Result<(), Box<dyn std::error::Error>> {
    use std::path::Path;
    use tokio::net::UnixListener;
    use tokio_stream::wrappers::UnixListenerStream;

    let svc = AudioServiceServer::new(service);

    // Remove existing socket file if it exists
    if Path::new(socket_path).exists() {
        std::fs::remove_file(socket_path)?;
        info!("üóëÔ∏è Removed existing socket file: {}", socket_path);
    }

    // Create Unix domain socket listener
    let uds = UnixListener::bind(socket_path)?;
    info!(
        "üéµ Audio service listening on Unix domain socket: {}",
        socket_path
    );

    // Convert UnixListener to Tonic's transport using UnixListenerStream
    let incoming = UnixListenerStream::new(uds);

    Server::builder()
        .add_service(svc)
        .serve_with_incoming(incoming)
        .await?;

    Ok(())
}
