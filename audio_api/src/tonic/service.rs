use crate::{
    audio_sink::{AudioSink, CpalConfig, CpalSink},
    audio_source::{AudioCapture, AudioCaptureConfig},
    error::AudioError,
};
use futures::StreamExt;
use log::{debug, error, info, warn};
use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};
use tonic::transport::Server;
use tonic::{Request, Response, Status};

use crate::types::AUDIO_CHUNK_SIZE;
use audio::audio_service_server::{AudioService, AudioServiceServer};
use audio::{
    play_audio_request, AbortRequest, AbortResponse, AudioChunk, EndStreamRequest,
    EndStreamResponse, PlayAudioRequest, PlayResponse, SubscribeRequest,
};

// Generated by tonic-build
pub mod audio {
    tonic::include_proto!("audio");
}

/// Active audio stream information
struct ActiveStream {
    stream_id: String,
    abort_tx: mpsc::Sender<()>,
    task_handle: tokio::task::JoinHandle<Result<(), AudioError>>,
}

/// Main audio service implementation
pub struct AudioServiceImpl {
    capture_config: AudioCaptureConfig,
    playback_config: CpalConfig,
    active_streams: Arc<Mutex<std::collections::HashMap<String, ActiveStream>>>,
}

impl AudioServiceImpl {
    pub fn new() -> Self {
        Self {
            capture_config: AudioCaptureConfig::default(),
            playback_config: CpalConfig::default(),
            active_streams: Arc::new(Mutex::new(std::collections::HashMap::new())),
        }
    }

    pub fn with_configs(capture_config: AudioCaptureConfig, playback_config: CpalConfig) -> Self {
        Self {
            capture_config,
            playback_config,
            active_streams: Arc::new(Mutex::new(std::collections::HashMap::new())),
        }
    }

    /// Handle audio playback for a specific stream
    async fn handle_playback(
        &self,
        mut stream: tonic::Streaming<PlayAudioRequest>,
    ) -> Result<PlayResponse, Status> {
        let mut current_stream_id = None;
        let mut sink = None;
        let mut chunks_played = 0;

        debug!("üîä Starting playback stream processing");

        // Process stream requests
        while let Some(request) = stream.next().await {
            let request = request?;

            match request.data {
                Some(play_audio_request::Data::Chunk(chunk)) => {
                    // Initialize stream if this is the first chunk
                    if current_stream_id.is_none() {
                        current_stream_id = Some(request.stream_id.clone());
                        info!("üîä Initializing playback stream: {}", request.stream_id);

                        // Create new audio sink
                        let new_sink =
                            CpalSink::new(self.playback_config.clone()).map_err(|e| {
                                error!("Failed to create audio sink: {}", e);
                                Status::internal(format!("Failed to create audio sink: {}", e))
                            })?;

                        // Create abort channel
                        let (tx, _rx) = mpsc::channel::<()>(1);

                        // Store the stream
                        {
                            let mut streams = self.active_streams.lock().await;
                            streams.insert(
                                request.stream_id.clone(),
                                ActiveStream {
                                    stream_id: request.stream_id.clone(),
                                    abort_tx: tx,
                                    task_handle: tokio::task::spawn(async { Ok(()) }), // Placeholder
                                },
                            );
                        }

                        sink = Some(new_sink);
                        info!("üîä Playback stream initialized successfully");
                    }

                    // Validate chunk size
                    if chunk.samples.len() != AUDIO_CHUNK_SIZE {
                        return Err(Status::invalid_argument(format!(
                            "Invalid chunk size: expected {}, got {}",
                            AUDIO_CHUNK_SIZE,
                            chunk.samples.len()
                        )));
                    }

                    // Convert to fixed array and play
                    let samples: [f32; AUDIO_CHUNK_SIZE] = chunk
                        .samples
                        .try_into()
                        .map_err(|_| Status::invalid_argument("Failed to convert samples"))?;

                    if let Some(ref sink) = sink {
                        // Convert samples to bytes for sink
                        let audio_data: Vec<u8> = samples
                            .iter()
                            .flat_map(|&sample| sample.to_le_bytes())
                            .collect();

                        sink.write(&audio_data).await.map_err(|e| {
                            error!("Playback error: {}", e);
                            Status::internal(format!("Playback error: {}", e))
                        })?;
                        chunks_played += 1;
                        debug!(
                            "üîä Played chunk {} for stream {}",
                            chunks_played,
                            current_stream_id.as_ref().unwrap()
                        );
                    }
                }
                Some(play_audio_request::Data::EndStream(_)) => {
                    // Stream ended normally
                    info!(
                        "üîä Stream {} ended normally",
                        current_stream_id.as_ref().unwrap_or(&"unknown".to_string())
                    );
                    break;
                }
                None => {
                    return Err(Status::invalid_argument("Missing data in PlayAudioRequest"));
                }
            }
        }

        // Clean up stream
        if let Some(stream_id) = current_stream_id {
            let mut streams = self.active_streams.lock().await;
            streams.remove(&stream_id);
            debug!("üîä Cleaned up stream: {}", stream_id);
        }

        info!("üîä Playback completed: {} chunks played", chunks_played);
        Ok(PlayResponse {
            success: true,
            message: format!(
                "Playback completed successfully. {} chunks played.",
                chunks_played
            ),
        })
    }
}

#[tonic::async_trait]
impl AudioService for AudioServiceImpl {
    type SubscribeAudioStream =
        std::pin::Pin<Box<dyn futures::Stream<Item = Result<AudioChunk, Status>> + Send + 'static>>;

    async fn subscribe_audio(
        &self,
        _request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeAudioStream>, Status> {
        info!("üé§ Starting audio capture subscription");
        let (tx, rx) = mpsc::channel(100);

        // Start audio capture using existing module
        let capture = AudioCapture::new(self.capture_config.clone(), tx).map_err(|e| {
            error!("Failed to start audio capture: {}", e);
            Status::internal(format!("Failed to start audio capture: {}", e))
        })?;

        info!("üé§ Audio capture started successfully");

        // Convert to Tonic stream
        let stream = tokio_stream::wrappers::ReceiverStream::new(rx)
            .map(|chunk| AudioChunk {
                samples: chunk.to_vec(),
                timestamp_ms: std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_millis() as u64,
            })
            .map(Ok);

        // Keep capture alive
        let _keep_alive = capture;

        Ok(Response::new(Box::pin(stream)))
    }

    async fn play_audio(
        &self,
        request: Request<tonic::Streaming<PlayAudioRequest>>,
    ) -> Result<Response<PlayResponse>, Status> {
        info!("üîä Starting audio playback stream");
        let stream = request.into_inner();
        let result = self.handle_playback(stream).await;
        match &result {
            Ok(response) => info!("üîä Audio playback completed: {}", response.message),
            Err(e) => error!("üîä Audio playback failed: {}", e),
        }
        Ok(Response::new(result?))
    }

    async fn end_audio_stream(
        &self,
        request: Request<EndStreamRequest>,
    ) -> Result<Response<EndStreamResponse>, Status> {
        let stream_id = request.into_inner().stream_id;
        info!("‚èπÔ∏è Ending audio stream: {}", stream_id);
        let mut streams = self.active_streams.lock().await;

        if let Some(stream) = streams.remove(&stream_id) {
            let _ = stream.abort_tx.send(()).await;
            info!("‚èπÔ∏è Stream {} ended successfully", stream_id);

            Ok(Response::new(EndStreamResponse {
                success: true,
                message: "Stream ended successfully".into(),
                chunks_played: 0, // TODO: Track chunks played
            }))
        } else {
            warn!("‚èπÔ∏è Stream {} not found", stream_id);
            Ok(Response::new(EndStreamResponse {
                success: false,
                message: "Stream not found".into(),
                chunks_played: 0,
            }))
        }
    }

    async fn abort_playback(
        &self,
        request: Request<AbortRequest>,
    ) -> Result<Response<AbortResponse>, Status> {
        let stream_id = request.into_inner().stream_id;
        info!("üõë Aborting audio playback: {}", stream_id);
        let mut streams = self.active_streams.lock().await;

        if let Some(stream) = streams.remove(&stream_id) {
            let _ = stream.abort_tx.send(()).await;
            info!("üõë Stream {} aborted successfully", stream_id);

            Ok(Response::new(AbortResponse {
                success: true,
                message: format!("Stream {} aborted successfully", stream_id),
            }))
        } else {
            warn!("üõë Stream {} not found for abort", stream_id);
            Ok(Response::new(AbortResponse {
                success: false,
                message: format!("Stream {} not found", stream_id),
            }))
        }
    }
}

/// Helper function to create and run the Tonic server on TCP
pub async fn run_server(
    addr: std::net::SocketAddr,
    service: AudioServiceImpl,
) -> Result<(), Box<dyn std::error::Error>> {
    let svc = AudioServiceServer::new(service);

    info!("üéµ Audio service listening on TCP {}", addr);

    Server::builder().add_service(svc).serve(addr).await?;

    Ok(())
}

/// Helper function to create and run the Tonic server on Unix domain socket
pub async fn run_server_unix(
    socket_path: &str,
    service: AudioServiceImpl,
) -> Result<(), Box<dyn std::error::Error>> {
    use std::path::Path;
    use tokio::net::UnixListener;
    use tokio_stream::wrappers::UnixListenerStream;

    let svc = AudioServiceServer::new(service);

    // Remove existing socket file if it exists
    if Path::new(socket_path).exists() {
        std::fs::remove_file(socket_path)?;
        info!("üóëÔ∏è Removed existing socket file: {}", socket_path);
    }

    // Create Unix domain socket listener
    let uds = UnixListener::bind(socket_path)?;
    info!(
        "üéµ Audio service listening on Unix domain socket: {}",
        socket_path
    );

    // Convert UnixListener to Tonic's transport using UnixListenerStream
    let incoming = UnixListenerStream::new(uds);

    Server::builder()
        .add_service(svc)
        .serve_with_incoming(incoming)
        .await?;

    Ok(())
}
